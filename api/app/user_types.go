// Code generated by goagen v1.4.1, DO NOT EDIT.
//
// API "rankdb": Application User Types
//
// Command:
// $ goagen
// --design=github.com/Vivino/rankdb/api/design
// --out=$(GOPATH)/src/github.com/Vivino/rankdb/api
// --version=v1.4.1

package app

import (
	"encoding/json"
	"unicode/utf8"

	"github.com/goadesign/goa"
)

// backupDestination user type.
type backupDestination struct {
	// Specifies the destination path.
	// If type is server, this should be ip+port of the other server, eg. 10.0.0.1:8080.
	// If the type is s3, the source should be specified as s3://bucket/path/file.bin. Replace bucket and path+file
	Path *string `form:"path,omitempty" json:"path,omitempty" yaml:"path,omitempty" xml:"path,omitempty"`
	// Optional alternative list id prefix for server-to-server transfers.
	// If not provided the original list id/segment ids will be used and any existing list will be overwritten.
	ServerListIDPrefix *string `form:"server_list_id_prefix,omitempty" json:"server_list_id_prefix,omitempty" yaml:"server_list_id_prefix,omitempty" xml:"server_list_id_prefix,omitempty"`
	// Optional alternative list id suffix for server-to-server transfers.
	// If not provided the original list id/segment ids will be used and any existing list will be overwritten.
	ServerListIDSuffix *string `form:"server_list_id_suffix,omitempty" json:"server_list_id_suffix,omitempty" yaml:"server_list_id_suffix,omitempty" xml:"server_list_id_suffix,omitempty"`
	// Specifies the destination type of the backup. Can be 'file' 'download', 's3' or 'server'
	Type *string `form:"type,omitempty" json:"type,omitempty" yaml:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the backupDestination type instance.
func (ut *backupDestination) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	return
}

// Publicize creates BackupDestination from backupDestination
func (ut *backupDestination) Publicize() *BackupDestination {
	var pub BackupDestination
	if ut.Path != nil {
		pub.Path = ut.Path
	}
	if ut.ServerListIDPrefix != nil {
		pub.ServerListIDPrefix = ut.ServerListIDPrefix
	}
	if ut.ServerListIDSuffix != nil {
		pub.ServerListIDSuffix = ut.ServerListIDSuffix
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// BackupDestination user type.
type BackupDestination struct {
	// Specifies the destination path.
	// If type is server, this should be ip+port of the other server, eg. 10.0.0.1:8080.
	// If the type is s3, the source should be specified as s3://bucket/path/file.bin. Replace bucket and path+file
	Path *string `form:"path,omitempty" json:"path,omitempty" yaml:"path,omitempty" xml:"path,omitempty"`
	// Optional alternative list id prefix for server-to-server transfers.
	// If not provided the original list id/segment ids will be used and any existing list will be overwritten.
	ServerListIDPrefix *string `form:"server_list_id_prefix,omitempty" json:"server_list_id_prefix,omitempty" yaml:"server_list_id_prefix,omitempty" xml:"server_list_id_prefix,omitempty"`
	// Optional alternative list id suffix for server-to-server transfers.
	// If not provided the original list id/segment ids will be used and any existing list will be overwritten.
	ServerListIDSuffix *string `form:"server_list_id_suffix,omitempty" json:"server_list_id_suffix,omitempty" yaml:"server_list_id_suffix,omitempty" xml:"server_list_id_suffix,omitempty"`
	// Specifies the destination type of the backup. Can be 'file' 'download', 's3' or 'server'
	Type string `form:"type" json:"type" yaml:"type" xml:"type"`
}

// Validate validates the BackupDestination type instance.
func (ut *BackupDestination) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	return
}

// element user type.
type element struct {
	// ID of element
	ID *uint64 `form:"id,omitempty" json:"id,omitempty" yaml:"id,omitempty" xml:"id,omitempty"`
	// Custom payload. Stored untouched. On updates null means do not update. `{}` is the empty value.
	Payload json.RawMessage `form:"payload,omitempty" json:"payload,omitempty" yaml:"payload,omitempty" xml:"payload,omitempty"`
	// Score of the element. Higher score gives higher placement.
	Score *uint64 `form:"score,omitempty" json:"score,omitempty" yaml:"score,omitempty" xml:"score,omitempty"`
	// Tie breaker, used if score matches for consistent sorting. Higher value = higher placement if score is equal.
	TieBreaker *uint32 `form:"tie_breaker,omitempty" json:"tie_breaker,omitempty" yaml:"tie_breaker,omitempty" xml:"tie_breaker,omitempty"`
}

// Validate validates the element type instance.
func (ut *element) Validate() (err error) {
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Score == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "score"))
	}
	if ut.ID != nil {
		if *ut.ID < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.id`, *ut.ID, 0, true))
		}
	}
	if ut.Score != nil {
		if *ut.Score < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.score`, *ut.Score, 0, true))
		}
	}
	if ut.TieBreaker != nil {
		if *ut.TieBreaker < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.tie_breaker`, *ut.TieBreaker, 0, true))
		}
	}
	if ut.TieBreaker != nil {
		if *ut.TieBreaker > 4294967295 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.tie_breaker`, *ut.TieBreaker, 4294967295, false))
		}
	}
	return
}

// Publicize creates Element from element
func (ut *element) Publicize() *Element {
	var pub Element
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Payload != nil {
		pub.Payload = ut.Payload
	}
	if ut.Score != nil {
		pub.Score = *ut.Score
	}
	if ut.TieBreaker != nil {
		pub.TieBreaker = ut.TieBreaker
	}
	return &pub
}

// Element user type.
type Element struct {
	// ID of element
	ID uint64 `form:"id" json:"id" yaml:"id" xml:"id"`
	// Custom payload. Stored untouched. On updates null means do not update. `{}` is the empty value.
	Payload json.RawMessage `form:"payload,omitempty" json:"payload,omitempty" yaml:"payload,omitempty" xml:"payload,omitempty"`
	// Score of the element. Higher score gives higher placement.
	Score uint64 `form:"score" json:"score" yaml:"score" xml:"score"`
	// Tie breaker, used if score matches for consistent sorting. Higher value = higher placement if score is equal.
	TieBreaker *uint32 `form:"tie_breaker,omitempty" json:"tie_breaker,omitempty" yaml:"tie_breaker,omitempty" xml:"tie_breaker,omitempty"`
}

// Validate validates the Element type instance.
func (ut *Element) Validate() (err error) {

	if ut.ID < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`type.id`, ut.ID, 0, true))
	}
	if ut.Score < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`type.score`, ut.Score, 0, true))
	}
	if ut.TieBreaker != nil {
		if *ut.TieBreaker < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`type.tie_breaker`, *ut.TieBreaker, 0, true))
		}
	}
	if ut.TieBreaker != nil {
		if *ut.TieBreaker > 4294967295 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`type.tie_breaker`, *ut.TieBreaker, 4294967295, false))
		}
	}
	return
}

// listPayloadQL user type.
type listPayloadQL struct {
	// Include all lists in these sets
	AllInSets []string `form:"all_in_sets,omitempty" json:"all_in_sets,omitempty" yaml:"all_in_sets,omitempty" xml:"all_in_sets,omitempty"`
	// Include lists that match exact list names
	Lists []string `form:"lists,omitempty" json:"lists,omitempty" yaml:"lists,omitempty" xml:"lists,omitempty"`
	// Include lists that match all values in metadata
	MatchMetadata map[string]string `form:"match_metadata,omitempty" json:"match_metadata,omitempty" yaml:"match_metadata,omitempty" xml:"match_metadata,omitempty"`
	// Payloads for create/update functions.
	// Will be ignored on deletes.
	Payload []*element `form:"payload,omitempty" json:"payload,omitempty" yaml:"payload,omitempty" xml:"payload,omitempty"`
}

// Validate validates the listPayloadQL type instance.
func (ut *listPayloadQL) Validate() (err error) {
	for _, e := range ut.Payload {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Publicize creates ListPayloadQL from listPayloadQL
func (ut *listPayloadQL) Publicize() *ListPayloadQL {
	var pub ListPayloadQL
	if ut.AllInSets != nil {
		pub.AllInSets = ut.AllInSets
	}
	if ut.Lists != nil {
		pub.Lists = ut.Lists
	}
	if ut.MatchMetadata != nil {
		pub.MatchMetadata = ut.MatchMetadata
	}
	if ut.Payload != nil {
		pub.Payload = make([]*Element, len(ut.Payload))
		for i2, elem2 := range ut.Payload {
			pub.Payload[i2] = elem2.Publicize()
		}
	}
	return &pub
}

// ListPayloadQL user type.
type ListPayloadQL struct {
	// Include all lists in these sets
	AllInSets []string `form:"all_in_sets,omitempty" json:"all_in_sets,omitempty" yaml:"all_in_sets,omitempty" xml:"all_in_sets,omitempty"`
	// Include lists that match exact list names
	Lists []string `form:"lists,omitempty" json:"lists,omitempty" yaml:"lists,omitempty" xml:"lists,omitempty"`
	// Include lists that match all values in metadata
	MatchMetadata map[string]string `form:"match_metadata,omitempty" json:"match_metadata,omitempty" yaml:"match_metadata,omitempty" xml:"match_metadata,omitempty"`
	// Payloads for create/update functions.
	// Will be ignored on deletes.
	Payload []*Element `form:"payload,omitempty" json:"payload,omitempty" yaml:"payload,omitempty" xml:"payload,omitempty"`
}

// Validate validates the ListPayloadQL type instance.
func (ut *ListPayloadQL) Validate() (err error) {
	for _, e := range ut.Payload {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// listQL user type.
type listQL struct {
	// Include all lists in these sets
	AllInSets []string `form:"all_in_sets,omitempty" json:"all_in_sets,omitempty" yaml:"all_in_sets,omitempty" xml:"all_in_sets,omitempty"`
	// Include lists that match exact list names
	Lists []string `form:"lists,omitempty" json:"lists,omitempty" yaml:"lists,omitempty" xml:"lists,omitempty"`
	// Include lists that match all values in metadata
	MatchMetadata map[string]string `form:"match_metadata,omitempty" json:"match_metadata,omitempty" yaml:"match_metadata,omitempty" xml:"match_metadata,omitempty"`
}

// Publicize creates ListQL from listQL
func (ut *listQL) Publicize() *ListQL {
	var pub ListQL
	if ut.AllInSets != nil {
		pub.AllInSets = ut.AllInSets
	}
	if ut.Lists != nil {
		pub.Lists = ut.Lists
	}
	if ut.MatchMetadata != nil {
		pub.MatchMetadata = ut.MatchMetadata
	}
	return &pub
}

// ListQL user type.
type ListQL struct {
	// Include all lists in these sets
	AllInSets []string `form:"all_in_sets,omitempty" json:"all_in_sets,omitempty" yaml:"all_in_sets,omitempty" xml:"all_in_sets,omitempty"`
	// Include lists that match exact list names
	Lists []string `form:"lists,omitempty" json:"lists,omitempty" yaml:"lists,omitempty" xml:"lists,omitempty"`
	// Include lists that match all values in metadata
	MatchMetadata map[string]string `form:"match_metadata,omitempty" json:"match_metadata,omitempty" yaml:"match_metadata,omitempty" xml:"match_metadata,omitempty"`
}

// multiElement user type.
type multiElement struct {
	// IDs of elements
	ElementIds []uint64 `form:"element_ids,omitempty" json:"element_ids,omitempty" yaml:"element_ids,omitempty" xml:"element_ids,omitempty"`
}

// Validate validates the multiElement type instance.
func (ut *multiElement) Validate() (err error) {
	if ut.ElementIds == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "element_ids"))
	}
	for _, e := range ut.ElementIds {
		if e < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.element_ids[*]`, e, 0, true))
		}
	}
	return
}

// Publicize creates MultiElement from multiElement
func (ut *multiElement) Publicize() *MultiElement {
	var pub MultiElement
	if ut.ElementIds != nil {
		pub.ElementIds = ut.ElementIds
	}
	return &pub
}

// MultiElement user type.
type MultiElement struct {
	// IDs of elements
	ElementIds []uint64 `form:"element_ids" json:"element_ids" yaml:"element_ids" xml:"element_ids"`
}

// Validate validates the MultiElement type instance.
func (ut *MultiElement) Validate() (err error) {
	if ut.ElementIds == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "element_ids"))
	}
	for _, e := range ut.ElementIds {
		if e < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`type.element_ids[*]`, e, 0, true))
		}
	}
	return
}

// multiListBackup user type.
type multiListBackup struct {
	Destination *backupDestination `form:"destination,omitempty" json:"destination,omitempty" yaml:"destination,omitempty" xml:"destination,omitempty"`
	Lists       *listQL            `form:"lists,omitempty" json:"lists,omitempty" yaml:"lists,omitempty" xml:"lists,omitempty"`
}

// Validate validates the multiListBackup type instance.
func (ut *multiListBackup) Validate() (err error) {
	if ut.Destination == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "destination"))
	}
	if ut.Lists == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "lists"))
	}
	if ut.Destination != nil {
		if err2 := ut.Destination.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates MultiListBackup from multiListBackup
func (ut *multiListBackup) Publicize() *MultiListBackup {
	var pub MultiListBackup
	if ut.Destination != nil {
		pub.Destination = ut.Destination.Publicize()
	}
	if ut.Lists != nil {
		pub.Lists = ut.Lists.Publicize()
	}
	return &pub
}

// MultiListBackup user type.
type MultiListBackup struct {
	Destination *BackupDestination `form:"destination" json:"destination" yaml:"destination" xml:"destination"`
	Lists       *ListQL            `form:"lists" json:"lists" yaml:"lists" xml:"lists"`
}

// Validate validates the MultiListBackup type instance.
func (ut *MultiListBackup) Validate() (err error) {
	if ut.Destination == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "destination"))
	}
	if ut.Lists == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "lists"))
	}
	if ut.Destination != nil {
		if err2 := ut.Destination.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// rankList user type.
type rankList struct {
	// The ID of the list to apply the operation on.
	// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
	ID *string `form:"id,omitempty" json:"id,omitempty" yaml:"id,omitempty" xml:"id,omitempty"`
	// Load Index on server startup
	LoadIndex *bool `form:"load_index,omitempty" json:"load_index,omitempty" yaml:"load_index,omitempty" xml:"load_index,omitempty"`
	// Merge adjacent Segments with less than this number of entries
	MergeSize *int `form:"merge_size,omitempty" json:"merge_size,omitempty" yaml:"merge_size,omitempty" xml:"merge_size,omitempty"`
	// Custom metadata. String to String hash.
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" yaml:"metadata,omitempty" xml:"metadata,omitempty"`
	// Populate list with specified elements
	Populate []*element `form:"populate,omitempty" json:"populate,omitempty" yaml:"populate,omitempty" xml:"populate,omitempty"`
	// Set used for storage
	Set *string `form:"set,omitempty" json:"set,omitempty" yaml:"set,omitempty" xml:"set,omitempty"`
	// Split Segments larger than this number of entries
	SplitSize *int `form:"split_size,omitempty" json:"split_size,omitempty" yaml:"split_size,omitempty" xml:"split_size,omitempty"`
}

// Finalize sets the default values for rankList type instance.
func (ut *rankList) Finalize() {
	var defaultLoadIndex = false
	if ut.LoadIndex == nil {
		ut.LoadIndex = &defaultLoadIndex
	}
	var defaultMergeSize = 500
	if ut.MergeSize == nil {
		ut.MergeSize = &defaultMergeSize
	}
	var defaultSplitSize = 2000
	if ut.SplitSize == nil {
		ut.SplitSize = &defaultSplitSize
	}
}

// Validate validates the rankList type instance.
func (ut *rankList) Validate() (err error) {
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Set == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "set"))
	}
	if ut.ID != nil {
		if ok := goa.ValidatePattern(`^[a-zA-Z0-9-_.]+$`, *ut.ID); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.id`, *ut.ID, `^[a-zA-Z0-9-_.]+$`))
		}
	}
	if ut.ID != nil {
		if utf8.RuneCountInString(*ut.ID) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.id`, *ut.ID, utf8.RuneCountInString(*ut.ID), 2, true))
		}
	}
	if ut.ID != nil {
		if utf8.RuneCountInString(*ut.ID) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.id`, *ut.ID, utf8.RuneCountInString(*ut.ID), 100, false))
		}
	}
	if ut.MergeSize != nil {
		if *ut.MergeSize < 10 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.merge_size`, *ut.MergeSize, 10, true))
		}
	}
	if ut.MergeSize != nil {
		if *ut.MergeSize > 100000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.merge_size`, *ut.MergeSize, 100000, false))
		}
	}
	for _, e := range ut.Populate {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if ut.Set != nil {
		if utf8.RuneCountInString(*ut.Set) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.set`, *ut.Set, utf8.RuneCountInString(*ut.Set), 2, true))
		}
	}
	if ut.Set != nil {
		if utf8.RuneCountInString(*ut.Set) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.set`, *ut.Set, utf8.RuneCountInString(*ut.Set), 100, false))
		}
	}
	if ut.SplitSize != nil {
		if *ut.SplitSize < 10 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.split_size`, *ut.SplitSize, 10, true))
		}
	}
	if ut.SplitSize != nil {
		if *ut.SplitSize > 100000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.split_size`, *ut.SplitSize, 100000, false))
		}
	}
	return
}

// Publicize creates RankList from rankList
func (ut *rankList) Publicize() *RankList {
	var pub RankList
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.LoadIndex != nil {
		pub.LoadIndex = *ut.LoadIndex
	}
	if ut.MergeSize != nil {
		pub.MergeSize = *ut.MergeSize
	}
	if ut.Metadata != nil {
		pub.Metadata = ut.Metadata
	}
	if ut.Populate != nil {
		pub.Populate = make([]*Element, len(ut.Populate))
		for i2, elem2 := range ut.Populate {
			pub.Populate[i2] = elem2.Publicize()
		}
	}
	if ut.Set != nil {
		pub.Set = *ut.Set
	}
	if ut.SplitSize != nil {
		pub.SplitSize = *ut.SplitSize
	}
	return &pub
}

// RankList user type.
type RankList struct {
	// The ID of the list to apply the operation on.
	// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
	ID string `form:"id" json:"id" yaml:"id" xml:"id"`
	// Load Index on server startup
	LoadIndex bool `form:"load_index" json:"load_index" yaml:"load_index" xml:"load_index"`
	// Merge adjacent Segments with less than this number of entries
	MergeSize int `form:"merge_size" json:"merge_size" yaml:"merge_size" xml:"merge_size"`
	// Custom metadata. String to String hash.
	Metadata map[string]string `form:"metadata,omitempty" json:"metadata,omitempty" yaml:"metadata,omitempty" xml:"metadata,omitempty"`
	// Populate list with specified elements
	Populate []*Element `form:"populate,omitempty" json:"populate,omitempty" yaml:"populate,omitempty" xml:"populate,omitempty"`
	// Set used for storage
	Set string `form:"set" json:"set" yaml:"set" xml:"set"`
	// Split Segments larger than this number of entries
	SplitSize int `form:"split_size" json:"split_size" yaml:"split_size" xml:"split_size"`
}

// Validate validates the RankList type instance.
func (ut *RankList) Validate() (err error) {
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Set == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "set"))
	}
	if ok := goa.ValidatePattern(`^[a-zA-Z0-9-_.]+$`, ut.ID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`type.id`, ut.ID, `^[a-zA-Z0-9-_.]+$`))
	}
	if utf8.RuneCountInString(ut.ID) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.id`, ut.ID, utf8.RuneCountInString(ut.ID), 2, true))
	}
	if utf8.RuneCountInString(ut.ID) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.id`, ut.ID, utf8.RuneCountInString(ut.ID), 100, false))
	}
	if ut.MergeSize < 10 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`type.merge_size`, ut.MergeSize, 10, true))
	}
	if ut.MergeSize > 100000 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`type.merge_size`, ut.MergeSize, 100000, false))
	}
	for _, e := range ut.Populate {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if utf8.RuneCountInString(ut.Set) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.set`, ut.Set, utf8.RuneCountInString(ut.Set), 2, true))
	}
	if utf8.RuneCountInString(ut.Set) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.set`, ut.Set, utf8.RuneCountInString(ut.Set), 100, false))
	}
	if ut.SplitSize < 10 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`type.split_size`, ut.SplitSize, 10, true))
	}
	if ut.SplitSize > 100000 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`type.split_size`, ut.SplitSize, 100000, false))
	}
	return
}
